// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.10 (swiftlang-5.10.0.13 clang-1500.3.9.4)
// swift-module-flags: -target arm64-apple-ios15.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-bare-slash-regex -module-name TruID
import AVFoundation
import Accelerate
import CoreFoundation
import CoreGraphics
import CoreImage
import CoreLocation
import CoreMedia
import CoreVideo
import Darwin
import DeveloperToolsSupport
import Foundation
import QuartzCore
import Swift
import SwiftUI
import TensorFlowLiteC
import TensorFlowLiteTaskVision
@_exported import TruID
import UIKit
import VideoToolbox
import Vision
import _Concurrency
import _MapKit_SwiftUI
import _StringProcessing
import _SwiftConcurrencyShims
public struct LivenessData : Swift.Codable {
  public var right4: Swift.Bool?
  public var left4: Swift.Bool?
  public var rightThumb: Swift.Bool?
  public var leftThumb: Swift.Bool?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public enum FingersToScan : Swift.CaseIterable {
  case LEFT_4
  case RIGHT_4
  case RIGHT_THUMB
  case LEFT_THUMB
  case LEFT_4_RIGHT_4
  case ALL_10_FINGERS
  public static func == (a: TruID.FingersToScan, b: TruID.FingersToScan) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [TruID.FingersToScan]
  public static var allCases: [TruID.FingersToScan] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
public struct FingerData : Swift.Codable {
  public let WSQ: Swift.String?
  public let ISO: Swift.String?
  public let NFIQ: Swift.Float?
  public let imageBase64: Swift.String?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct FingerprintsData : Swift.Codable {
  public var finger1: TruID.FingerData
  public var finger2: TruID.FingerData
  public var finger3: TruID.FingerData
  public var finger4: TruID.FingerData
  public var finger5: TruID.FingerData
  public var finger6: TruID.FingerData
  public var finger7: TruID.FingerData
  public var finger8: TruID.FingerData
  public var finger9: TruID.FingerData
  public var finger10: TruID.FingerData
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension Foundation.Bundle {
  public class func current(dsoHandle: Swift.UnsafeRawPointer = #dsohandle) -> Foundation.Bundle
}
public enum StatusValue : Swift.Codable {
  case string(Swift.String)
  case bool(Swift.Bool)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public var value: Swift.Bool {
    get
  }
}
public struct ReportStep : Swift.Codable {
  public let status: TruID.StatusValue?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct ExtractedData : Swift.Codable {
  public let Name: Swift.String?
  public let Gender: Swift.String?
  public let FatherName: Swift.String?
  public let DateOfBirth: Swift.String?
  public let DateOfIssue: Swift.String?
  public let DateOfExpiry: Swift.String?
  public let IdentityNumber: Swift.String?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct DocumentCaptureReport : Swift.Codable {
  public let extracted_data: TruID.ExtractedData?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct DocumentCaptureReportStep : Swift.Codable {
  public let status: TruID.StatusValue?
  public let report: TruID.DocumentCaptureReport?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct Report : Swift.Codable {
  public let document_authenticity: TruID.ReportStep?
  public let document_capture: TruID.DocumentCaptureReportStep?
  public let face_liveness: TruID.ReportStep?
  public let id_to_selfie_matching: TruID.ReportStep?
  public let data_extraction: TruID.ReportStep?
  public let fingerprint_capture: TruID.ReportStep?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct Configuration : Swift.Codable {
  public let config: [TruID.Config]
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct Config : Swift.Codable {
  public let path: Swift.String?
  public let type: Swift.String
  public let required: Swift.Bool?
  public let step_config: TruID.StepConfig?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct StepConfig : Swift.Codable {
  public let id_to_selfie_matching: Swift.Bool?
  public let extract_data: Swift.Bool?
  public let document_authenticity: Swift.Bool?
  public let document_backside_capture: Swift.Bool?
  public let finger_selection: Swift.Bool?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct Session : Swift.Codable, Swift.Identifiable {
  public let id: Swift.Int
  public let status: Swift.String?
  public let configuration: TruID.Configuration
  public typealias ID = Swift.Int
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct SessionResult : Swift.Codable {
  public let id: Swift.Int
  public let report: TruID.Report?
  public let status: Swift.String?
  public let fingerprintsData: TruID.FingerprintsData
  public let livenessData: TruID.LivenessData
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public enum Runtime {
  public static var version: Swift.String {
    get
  }
}
extension UIKit.UIDevice {
  @_Concurrency.MainActor(unsafe) public static let modelName: Swift.String
}
public struct QuantizationParameters : Swift.Equatable, Swift.Hashable {
  public let scale: Swift.Float
  public let zeroPoint: Swift.Int
  public static func == (a: TruID.QuantizationParameters, b: TruID.QuantizationParameters) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_Concurrency.MainActor(unsafe) public struct FingerprintHelpScreen : SwiftUI.View {
  @_Concurrency.MainActor(unsafe) public var body: some SwiftUI.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s5TruID21FingerprintHelpScreenV4bodyQrvp", 0) __
}
public protocol CGSizePreferenceKey : SwiftUI.PreferenceKey where Self.Value == CoreFoundation.CGSize {
}
extension TruID.CGSizePreferenceKey {
  public static func reduce(value _: inout CoreFoundation.CGSize, nextValue: () -> CoreFoundation.CGSize)
}
extension SwiftUI.View {
  public func onSizeChanged<Key>(_ key: Key.Type, perform action: @escaping (CoreFoundation.CGSize) -> Swift.Void) -> some SwiftUI.View where Key : TruID.CGSizePreferenceKey
  
}
public enum SignatureRunnerError : Swift.Error, Swift.Equatable, Swift.Hashable {
  case invalidTensorDataCount(provided: Swift.Int, required: Swift.Int)
  case invalidTensorDataType
  case failedToCreateSignatureRunner(signatureKey: Swift.String)
  case failedToGetTensor(tensorType: Swift.String, nameInSignature: Swift.String)
  case failedToResizeInputTensor(inputName: Swift.String)
  case failedToCopyDataToInputTensor
  case failedToAllocateTensors
  case failedToInvokeSignature(signatureKey: Swift.String)
  case allocateTensorsRequired
  public static func == (a: TruID.SignatureRunnerError, b: TruID.SignatureRunnerError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension TruID.SignatureRunnerError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
extension TruID.SignatureRunnerError : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public enum InterpreterError : Swift.Error, Swift.Equatable, Swift.Hashable {
  case invalidTensorIndex(index: Swift.Int, maxIndex: Swift.Int)
  case invalidTensorDataCount(provided: Swift.Int, required: Swift.Int)
  case invalidTensorDataType
  case failedToLoadModel
  case failedToCreateInterpreter
  case failedToResizeInputTensor(index: Swift.Int)
  case failedToCopyDataToInputTensor
  case failedToAllocateTensors
  case allocateTensorsRequired
  case invokeInterpreterRequired
  case tensorFlowLiteError(Swift.String)
  public static func == (a: TruID.InterpreterError, b: TruID.InterpreterError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension TruID.InterpreterError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
extension TruID.InterpreterError : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@_Concurrency.MainActor(unsafe) public struct TruidMain : SwiftUI.View {
  @_Concurrency.MainActor(unsafe) public var body: some SwiftUI.View {
    get
  }
  @_Concurrency.MainActor(unsafe) public init(fingerprint_capture: Swift.Bool = true, fingerprint_selection: Swift.Bool = true, fingerprint_liveness: Swift.Bool = true, fingerprint_to_scan: TruID.FingersToScan = .RIGHT_4, enableHelpScreens: Swift.Bool = true, themeColor: SwiftUI.Color = Color(UIColor(red: 200/255, green: 100/255, blue: 200/255, alpha: 1.0)), success: @escaping (TruID.SessionResult) -> Swift.Void, failure: @escaping (Swift.String) -> Swift.Void)
  public typealias Body = @_opaqueReturnTypeOf("$s5TruID9TruidMainV4bodyQrvp", 0) __
}
public protocol Delegate : AnyObject {
  typealias CDelegate = Swift.UnsafeMutablePointer<TensorFlowLiteC.TfLiteDelegate>
  var cDelegate: Self.CDelegate { get }
}
public struct Tensor : Swift.Equatable, Swift.Hashable {
  public let name: Swift.String
  public let dataType: TruID.Tensor.DataType
  public let shape: TruID.Tensor.Shape
  public let data: Foundation.Data
  public let quantizationParameters: TruID.QuantizationParameters?
  public static func == (a: TruID.Tensor, b: TruID.Tensor) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension TruID.Tensor {
  public enum DataType : Swift.Equatable, Swift.Hashable {
    case bool
    case uInt8
    case int16
    case int32
    case int64
    case float16
    case float32
    case float64
    public static func == (a: TruID.Tensor.DataType, b: TruID.Tensor.DataType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension TruID.Tensor {
  public struct Shape : Swift.Equatable, Swift.Hashable {
    public let rank: Swift.Int
    public let dimensions: [Swift.Int]
    public init(_ dimensions: [Swift.Int])
    public init(_ elements: Swift.Int...)
    public static func == (a: TruID.Tensor.Shape, b: TruID.Tensor.Shape) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension TruID.Tensor.Shape : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral: Swift.Int...)
  public typealias ArrayLiteralElement = Swift.Int
}
@_hasMissingDesignatedInitializers final public class Interpreter {
  final public let options: TruID.Interpreter.Options?
  final public let delegates: [any TruID.Delegate]?
  final public var inputTensorCount: Swift.Int {
    get
  }
  final public var outputTensorCount: Swift.Int {
    get
  }
  final public var signatureKeys: [Swift.String] {
    get
  }
  convenience public init(modelPath: Swift.String, options: TruID.Interpreter.Options? = nil, delegates: [any TruID.Delegate]? = nil) throws
  convenience public init(modelData: Foundation.Data, options: TruID.Interpreter.Options? = nil, delegates: [any TruID.Delegate]? = nil) throws
  @objc deinit
  final public func invoke() throws
  final public func input(at index: Swift.Int) throws -> TruID.Tensor
  final public func output(at index: Swift.Int) throws -> TruID.Tensor
  final public func resizeInput(at index: Swift.Int, to shape: TruID.Tensor.Shape) throws
  @discardableResult
  final public func copy(_ data: Foundation.Data, toInputAt index: Swift.Int) throws -> TruID.Tensor
  final public func allocateTensors() throws
  final public func signatureRunner(with key: Swift.String) throws -> TruID.SignatureRunner
}
extension TruID.Interpreter {
  public struct Options : Swift.Equatable, Swift.Hashable {
    public var threadCount: Swift.Int?
    public var isXNNPackEnabled: Swift.Bool
    public init()
    public static func == (a: TruID.Interpreter.Options, b: TruID.Interpreter.Options) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(*, deprecated, renamed: "Interpreter.Options")
public typealias InterpreterOptions = TruID.Interpreter.Options
@_Concurrency.MainActor(unsafe) public struct FingerprintScreen : SwiftUI.View {
  @_Concurrency.MainActor(unsafe) public var body: some SwiftUI.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s5TruID17FingerprintScreenV4bodyQrvp", 0) __
}
@_hasMissingDesignatedInitializers final public class SignatureRunner {
  final public let signatureKey: Swift.String
  final public var inputs: [Swift.String] {
    get
  }
  final public var outputs: [Swift.String] {
    get
  }
  @objc deinit
  final public func invoke(with inputs: [Swift.String : Foundation.Data]) throws
  final public func input(named name: Swift.String) throws -> TruID.Tensor
  final public func output(named name: Swift.String) throws -> TruID.Tensor
  final public func resizeInput(named name: Swift.String, toShape shape: TruID.Tensor.Shape) throws
  final public func copy(_ data: Foundation.Data, toInputNamed name: Swift.String) throws
  final public func allocateTensors() throws
}
extension TruID.FingersToScan : Swift.Equatable {}
extension TruID.FingersToScan : Swift.Hashable {}
